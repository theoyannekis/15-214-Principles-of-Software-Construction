For my template method pattern implementation I didn’t have to change too much from my HW2 solution. I got rid of the SudokuSolutionVerifier interface because I felt like it wasn’t serving any useful purpose. Instead, I made a SudokuSolutionVerifier abstract class which implements all the invariant methods like isRowValid(), increasingAndUnique(), and isValidSudokuSolution(). That last method uses isSpecificPuzzleType which is left to be implemented by the classes that extend this abstract class to represent the qualities of that specific type of sudoku puzzle. This is because the specific qualifications of an individual type of Sudoku is not an invariant so it belongs in the subclasses. The only thing significant I changed from HW2 was moving the genericSudokuVerifier into its own subclass. On HW2 I just used the parent SudokuSolutionVerifier class to verify normal sudoku puzzles because that class contained all the functionality to check for that since the other types required it to be a normal sudoku too. However, to conform to the template design pattern I needed to move the genericSudokuVerifier to its own class because abstract classes can’t/aren’t supposed to be instantiated. Also, the subclasses are supposed to be the specific instances extending the abstract class, which wasn’t the case on my HW2 solution. A strength of this design is that I don’t have to copy paste all the isRowValid(), col, box, etc... code into each specific verifier. Also, I find it very clear to look at the abstract class and see what’s happening with these verifiers and to understand not just what methods all the verifiers have but how they are implemented when looking at the abstract class. A weakness is that its not super clear to understand the functionality of the specific verifiers when looking at that class, not the abstract class. A weakness is that it doesn’t extend well to other puzzles that don’t follow normal sudoku rules.
	For my strategy pattern implementation I have a sudokuSolutionVerifier interface pretty much identical to my one from HW2. I removed the SudokuVerifierClass that the other subclasses extended in my HW2 solutions. I had classes for each specific puzzle implementing the interface directly. All of these classes were basically the same as the SudokuSolutionVerifier class from HW2 with the specific puzzle check added. I had to copy all of the isRowValid() and other invariant code into each of these verifiers. There’s a ton of repeated code between the different verifiers. That’s a big downside. A plus is that each individual verifier has all of its methods inside of it so when looking at a specific verifier its clear to see all of its functionality. It extends pretty well to new puzzle types since all that ties the different puzzle verifiers together is the interface which only has one function, isValidSolution(). Another change I had to make was in the constructors I couldn’t just call super() anymore.
	I think that before Numbrix was added, the template method pattern was a much better choice than the strategy pattern. This is mainly because it prevents code reuse, and it makes it very clear what all these different verifiers are sharing between them. Its clear to see for example that all of the them use the isRowValid() method whereas in the strategy pattern method its harder to see the connection between each specific verifier. However, Numbrix introduced a new issue because the Numbrix puzzle is nothing like sudoku except for the fact that it deals with numbers and is on a 9x9 board. The validity of a Numbrix solution does not depend on rows, columns, or boxes like a normal Sudoku board. Therefore, to implement Numbrix in the pattern method pattern implementation I would have had to ignore the isValidSudokuSolution() that’s already in the abstract class and write a new verifier pretty much from scratch for nunbrix. It wouldn’t be using any methods besides isMatch() from the abstract class which makes it not a good choice. I chose to extend the strategy pattern implementation because the different verifiers in that case are only tied together by the interface which just has isValidSolution(). The numbrix solution has that function too, so that fits. All the functionality that is unique to numbrix goes in the numbrixverifier class. This is the point of the strategy pattern anyway, to have different implementations of an algorithm available at runtime. The numbrix verifier is very different than the others so it makes sense for it to be separate while still extending the interface. Also, there’s no reason for it to inherit all of those methods checking the rows and column validity since it doesn’t use them.
